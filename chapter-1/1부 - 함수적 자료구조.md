# 함수적 자료 구조

> 함수적 프로그래밍에서 자료구조를 정의하는 방법을 소개하고, 관련 기법은 패턴 부합도 설명한다.

> 순수 함수의 작성과 일반화를 익힌다.


* 함수적 자료구조란 오직 `순수 함수만으로 조작되는 자료구조`이다.
* 따라서 함수적 자료구조는 정의에 의해 불변이(immutable)이다.

> 자료형식을 도입할 때 `trait` 키워드를 사용한다.

> `sealed` 를 붙이는 것은 이 특질의 모든 구현이 반드시 이 파일 안에 선언되어야 함을 뜻한다.

> `case` 키워드로 시작하는 두 줄은 List의 두가지 구현, 즉 두가지 자료 생성자(data constructor)이다.

```
 case class Cons[+A](head: A, tail: List[A]) extends List[A]
```

> 에서 변수 A에 있는 +는 공변[covariant]을 뜻한다.

__

> Scala 에서 형식 매개변수 앞에 +, — 가 붙는 경우가 있다.

> +는 공변성(covariant), — 는 반공변성(contravariant), 아무것도 없으면 무공변성(invariant)을 말한다.

> 공변성(covariant)
> Liskov Substitution Principle 을 생각 하면 쉽다. A객체가 있고 A를 상속받은 A`가 있다면,

> 객체A`는 A대신에 사용 될수 있다.

> 반공변성(contravariant)

> 공변성의 반대 개념을 생각하면 쉽다. A객체가 있고 A를 상속받은 A`가 있다면, 객체A는 A`대신에 사용 될수 있다.

> 무공변성(invariant)
공변성과 반공변성의 성격을 둘다 갖지 않는다. 오로지 자기 자신만 사용이 가능하다.

[상세정보] :https://medium.com/@lazysoul/%EA%B3%B5%EB%B3%80%EA%B3%BC-%EB%B6%88%EB%B3%80-297cadba191#.f31eks62u


## 패턴 부합
> 패턴 부합은 표현식의 구조를 따라 내려가면서 그 구조의 부분 표현식을 추출하는 복잡한 switch 문과 비슷하게 작동한다.



`3.2 List의 첫 요소를 제거하는 함수 tail을 구현하라.`
```
Object List {
  def tail[A](lists :List[A]): List[A] = lists match {
      case Nil => List()
      case Cons(lists, listsX) => listsX
  }
}
```
