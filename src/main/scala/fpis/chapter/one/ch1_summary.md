# [ 스칼라로 배우는 함수형 프로그래밍 ]

## 1부. 함수형 프로그래밍 입문

### 1-1. 함수형프로그램이란 무엇인가

- 함수의 **부수효과** 를 제거하고 **순수성**, **참조투명성**을 유지하면 프로그램 추론이 쉬워지고 모듈성이 높아진다.

### 1-2. 스칼라로 함수형 프로그래밍 시작하기
< 함수형 프로그래밍에 사용되는 기법들을 구현하며 익힌다. >

- 함수의 인자로 함수를 넘길 수 있고 함수의 반환 값으로 함수를 반환할 수 있다. ( **고차함수** )
- 하나의 함수를 여러가지 타입에 대해 동작하도록 만들 수 있다. ( **다형적함수** )
- 함수 인자의 일부를 미리 적용시킨 함수를 만들 수 있다. ( **부분적용** )
- 함수에 인자를 하나씩 차례로 적용되도록 만들 수 있다. ( **커링** )
- A함수의 반환값이 B함수의 인자로 사용될 수 있으면 두 함수를 합성한 함수를 만들 수 있다. ( **함수합성** )

### 1-3. 함수적 자료구조
< 대수적 자료 형식인 List와 Tree를 구현해 보며 함수적 자료구조의 특성을 익힌다. >

- 불변 자료를 공유하여 재사용하는 방식으로 효율적인 자료구조를 만들 수 있다. ( **자료공유** )
- 자료 생성자들의 합과 곱으로 자료 형식을 정의할 수 있다. ( **대수적 자료 형식** : ex) Tree := Leaf v | Branch(Tree, Tree) )
- 자료 생성자들의 형식에 따라 분기하도록 함수를 정의할 수 있다. ( **패턴부합** )
- 목록을 순회하며 값을 축약하는 작업을 고차 함수로 추상화할 수 있다. ( **접기함수** )
- 접기함수는 **꼬리재귀** 방식으로 구현 가능하여 스택넘침 없이 동작할 수 있다.
- 접기함수를 기반으로 다른 유용한 목록 조작 함수들을 **전부** 구현할 수 있다. ( 맵, 필터, ... )

### 1-4. 예외를 이용하지 않는 오류 처리
< Option과 Either를 구현해 보며 함수적 오류 처리 방식을 익힌다. >
 
- 예외를 보통의 값으로 표현하고 고차함수를 이용해 오류 처리 패턴을 추상화할 수 있다. ( **함수적 예외처리** )
- 예외를 던지는 대신 예외적인 조건이 발생했음을 뜻하는 값을 돌려준다. ( **오류 처리 통합** )
- 오류에 대해 에러 코드를 넘겨주는 대신 그러한 값을 대표하는 일반적인 형식을 도입한다. ( **형식에 안전** )
- 오류 처리와 전파, 복구에 관한 공통적인 패턴을 고차 함수로 캡슐화한다. ( **map, flatMap, getOrElse...** )
- 고차함수를 이용하면 여러 단계로 이루어진 계산이 **중간에 실패**할 경우 **나머지 계산 과정이 생략**된다. 
- 함수가 항상 답을 내지 못한다는 점을 반환 타입으로 표현한다. ( **Option 타입** )
- 일부 입력에 대해 정의되지 않는 **부분 함수**를 Option 타입을 반환하는 함수로 포장해 **완전 함수**로 만들 수 있다.
- map, lift, traverse 를 사용해 기존 함수의 수정없이 Option 값을 다룰 수 있다. ( **합성, 승급, 감싸기** )

### 1-5. 엄격성과 나태성
< 스트림을 구현해 보며 자료구조에 비엄격성을 적용해본다. >

- 비엄격성은 함수의 특성이며 모든 인수를 평가하는 엄격한 함수와 달리 비엄격한 함수는 인수가 평가되지 않을 수도 있다.
- 함수는 기본적으로 엄격하며 비엄격한 함수를 만드는 구문을 제공한다. ( **성크, 타입 앞 =>, &&과 ||**) 
- 평가되지 않은 채로 함수로 전달된 인수는 함수 본문에서 참조된 곳마다 평가된다.
- 비엄격한 함수의 성크(표현식의 평가되지 않은 형태)를 한 번만 평가되도록 캐시할 수 있다. ( **lazy val**  )
- 메모화가 적용된 **똑똑한 생성자**를 이용해 스트림 요소가 여러번 평가되지 않도록 할 수 있다.
- 비엄격성은 표현식의 서술과 표현식의 평가 방법 및 시기를 분리하여 모듈성을 높인다. ( **관심사의 분리** )
- 스트림은 순차열을 생성하는 계산을 구축하되 계산의 실행을 실제로 필요한 시점까지 미룰 수 있다.
- 스트림의 재귀는 비엄격성이 적용된 foldRight 형태로 구현하여 일부 단계만 평가되도록 할 수 있다. 
- 스트림 변환 시 요소가 참조되는 시점이 되어서야 스트림을 생성하는 계산이 진행된다. ( **점진적** )
- 스트림 변환 시 중간 스트림이 생성되지 않으므로 변환에 필요한 만큼만 메모리를 사용하고 변환 함수를 재사용하기 쉽다.
- 스트림 변환 함수가 점진적이기 때문에 무한 스트림에도 사용 가능하다.
- 초기 상태에 따라 현재 값과 다음 상태를 산출하는 과정을 무한히 반복하는 **공재귀** 함수를 만들 수 있다. ( unfold )

### 1-6. 순수 함수적 상태 
< 난수 발생기를 구현해 보며 상태를 다루는 함수적 프로그래밍 패턴을 익힌다. >

- 난수 발생 함수를 기존 상태에 따른 새 상태 및 난수의 쌍을 반환하도록 변경하여 순수 함수로 만들 수 있다.
- 동일한 기법을 상태가 있는 API 들을 순수하게 만드는 문제들에 적용할 수 있다.
- 상태 전이를 명시적으로 들어내는 패턴으로 상태 전이 함수를 순수하게 만들 수 있다. ( **oldState** -> (value,**newState**) )
- 기존 상태로부터 새 상태를 계산하는 방법을 함수 내부에 캡슐화하고 기존상태를 수정하지 않고 새 상태를 반환한다.
- 상태를 인수로 받고 그에 따른 결과와 새 상태를 반환하는 함수로 **부수효과 없이 명령식 프로그램을 작성**할 수 있다.
- unit, map, sequence 와 같은 고차함수(조합기)를 상태가 있는 동작을 처리(조합)하기 위한 범용 함수로 사용할 수 있다.
- 상태를 읽고 쓰는 동작과 다른 조합기들을 이용해 상태를 유지, 관리하는 프로그램을 순수 함수적 방식으로 구현할 수 있다.


